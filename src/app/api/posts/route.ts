
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import type { Post, User, Comment } from '@/lib/types';
import { categorizeContent, CategorizeContentInput } from '@/ai/flows/smart-content-categorization';
import { intelligentContentModeration, IntelligentContentModerationInput } from '@/ai/flows/intelligent-content-moderation';
import getDb from '@/lib/mongodb';
import { ObjectId } from 'mongodb';

// Schema for validating POST request body
const postFormSchema = z.object({
  userId: z.string().refine(val => ObjectId.isValid(val), { message: "Invalid User ID format." }),
  title: z.string().max(150, "Title can't exceed 150 characters.").optional(),
  content: z.string().min(1, 'Content is required.').max(5000, "Content can't exceed 5000 characters."),
  category: z.string().optional(),
  tags: z.string().optional(), // Comma-separated string
  isDraft: z.boolean().default(false),
  scheduledAt: z.string().datetime({ offset: true }).optional(),
});

// Define the structure of post documents in the database
type DbPost = Omit<Post, 'id' | 'author' | 'comments' | 'isLikedByCurrentUser' | 'isBookmarkedByCurrentUser' | 'authorId' | 'likedBy' | 'commentIds'> & {
  _id: ObjectId;
  authorId: ObjectId;
  likedBy: ObjectId[];
  commentIds: ObjectId[];
};
type DbComment = Omit<Comment, 'id' | 'author' | 'authorId' | 'postId'> & {
  _id: ObjectId;
  authorId: ObjectId;
  postId: ObjectId;
};


export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    const validation = postFormSchema.safeParse(body);
    if (!validation.success) {
      return NextResponse.json({ message: 'Invalid post data.', errors: validation.error.flatten().fieldErrors }, { status: 400 });
    }
    const data = validation.data;

    const db = await getDb();
    const usersCollection = db.collection<User>('users');
    const currentUserDoc = await usersCollection.findOne({ _id: new ObjectId(data.userId) }, {projection: {passwordHash: 0}});

    if (!currentUserDoc) {
        return NextResponse.json({ message: 'User not found. Cannot create post.' }, { status: 404 });
    }
    const currentUser: User = {...currentUserDoc, id: currentUserDoc._id!.toHexString(), bookmarkedPostIds: currentUserDoc.bookmarkedPostIds || [] };


    const moderationInput: IntelligentContentModerationInput = { content: data.content, sensitivityLevel: 'medium' };
    const moderationResult = await intelligentContentModeration(moderationInput);
    if (moderationResult.isFlagged) {
      return NextResponse.json({
        message: `Post flagged by content moderation: ${moderationResult.reason}. Please revise.`,
        isFlagged: true,
        reason: moderationResult.reason,
      }, { status: 400 });
    }

    let finalCategory = data.category;
    let finalTagsArray = data.tags ? data.tags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];

    if (!finalCategory || finalTagsArray.length === 0) {
        const categorizationInput: CategorizeContentInput = { content: data.content };
        try {
            const categorizationResult = await categorizeContent(categorizationInput);
            if (!finalCategory && categorizationResult.category) {
                finalCategory = categorizationResult.category;
            }
            if (finalTagsArray.length === 0 && categorizationResult.tags && categorizationResult.tags.length > 0) {
                finalTagsArray = [...new Set([...finalTagsArray, ...categorizationResult.tags])];
            }
        } catch (aiError) {
            console.warn("AI categorization failed, proceeding with user input or defaults:", aiError);
        }
    }

    const newPostDocument = {
      authorId: new ObjectId(data.userId),
      title: data.title,
      content: data.content,
      category: finalCategory,
      tags: finalTagsArray,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      likedBy: [] as ObjectId[], 
      likeCount: 0,
      commentIds: [] as ObjectId[], 
      commentCount: 0,
      status: data.isDraft ? 'draft' : (data.scheduledAt ? 'scheduled' : 'published'),
      scheduledAt: data.scheduledAt ? new Date(data.scheduledAt).toISOString() : undefined,
      // _id will be generated by MongoDB
    };

    const postsCollection = db.collection<Omit<DbPost, '_id'>>('posts'); // Type for insertion
    const result = await postsCollection.insertOne(newPostDocument);

    if (!result.insertedId) {
        throw new Error('Failed to insert post into database.');
    }
    
    const createdPostForClient: Post = {
        ...newPostDocument,
        _id: result.insertedId,
        id: result.insertedId.toHexString(),
        authorId: newPostDocument.authorId, 
        author: currentUser, 
        comments: [], 
        likedBy: [], 
        likeCount: 0,
        commentIds: [],
        commentCount: 0
    };

    return NextResponse.json({ message: 'Post created successfully!', post: createdPostForClient }, { status: 201 });

  } catch (error) {
    console.error('API Error creating post:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred.';
    return NextResponse.json({ message: errorMessage }, { status: 500 });
  }
}


export async function GET(request: NextRequest) {
  try {
    const db = await getDb();
    const postsCollection = db.collection<DbPost>('posts');
    const usersCollection = db.collection<User>('users');
    const commentsCollection = db.collection<DbComment>('comments');
    
    const { searchParams } = new URL(request.url);
    const authorIdParam = searchParams.get('authorId');
    const bookmarkedByIdParam = searchParams.get('bookmarkedById');
    const forUserIdParam = searchParams.get('forUserId'); 
    const statusParam = searchParams.get('status'); // 'published', 'draft', 'scheduled'

    let query: any = {}; 
    let currentUser: User | null = null;

    if (forUserIdParam && ObjectId.isValid(forUserIdParam)) {
        currentUser = await usersCollection.findOne({ _id: new ObjectId(forUserIdParam) });
    }


    if (bookmarkedByIdParam && ObjectId.isValid(bookmarkedByIdParam)) {
        const userWithBookmarks = await usersCollection.findOne({ _id: new ObjectId(bookmarkedByIdParam) });
        if (userWithBookmarks && userWithBookmarks.bookmarkedPostIds && userWithBookmarks.bookmarkedPostIds.length > 0) {
            query._id = { $in: userWithBookmarks.bookmarkedPostIds.map(id => new ObjectId(id)) };
        } else {
            return NextResponse.json([], { status: 200 }); 
        }
        query.status = 'published'; // Bookmarks are always for published posts
    } else if (authorIdParam && ObjectId.isValid(authorIdParam)) {
      query.authorId = new ObjectId(authorIdParam);
      if (statusParam && ['draft', 'scheduled', 'published'].includes(statusParam)) {
            query.status = statusParam;
        } else {
            query.status = 'published'; // Default to published if authorId is given but no specific status
        }
    } else {
        // General feed fetching - only published posts
        query.status = 'published';
    }


    const postsFromDb = await postsCollection.find(query).sort({ createdAt: -1 }).toArray();

    const enrichedPosts: Post[] = await Promise.all(
      postsFromDb.map(async (postDoc) => {
        const authorDoc = await usersCollection.findOne({ _id: new ObjectId(postDoc.authorId) }, {projection: {passwordHash: 0}});
        
        const authorForClient: User | undefined = authorDoc ? {
          ...authorDoc,
          id: authorDoc._id.toHexString(),
          bookmarkedPostIds: Array.isArray(authorDoc.bookmarkedPostIds) ? authorDoc.bookmarkedPostIds.map(id => new ObjectId(id.toString())) : [],
        } : undefined;
        
        
        const recentCommentsDocs = await commentsCollection
            .find({ postId: postDoc._id })
            .sort({ createdAt: -1 })
            .limit(2)
            .toArray();

        const recentCommentsPopulated: Comment[] = await Promise.all(
            recentCommentsDocs.map(async (commentDoc) => {
                const commentAuthorDoc = await usersCollection.findOne({_id: commentDoc.authorId}, {projection: {passwordHash: 0}});
                return {
                    ...commentDoc,
                    id: commentDoc._id.toHexString(),
                    postId: commentDoc.postId,
                    authorId: commentDoc.authorId,
                    author: commentAuthorDoc ? { ...commentAuthorDoc, id: commentAuthorDoc._id.toHexString(), bookmarkedPostIds: commentAuthorDoc.bookmarkedPostIds || [] } : undefined,
                } as Comment;
            })
        );
        
        const postLikedBy = Array.isArray(postDoc.likedBy) ? postDoc.likedBy : [];
        const isLikedByCurrentUser = currentUser && currentUser._id ? postLikedBy.some(id => id.equals(currentUser!._id!)) : false;
        
        const userBookmarkedPostIds = currentUser && Array.isArray(currentUser.bookmarkedPostIds) ? currentUser.bookmarkedPostIds : [];
        const isBookmarkedByCurrentUser = currentUser && postDoc._id ? userBookmarkedPostIds.some(id => id.equals(postDoc._id)) : false;


        return {
          ...postDoc,
          id: postDoc._id.toHexString(),
          authorId: postDoc.authorId, 
          author: authorForClient || { id: 'unknown', name: 'Unknown User', email:'', reputation: 0, joinedDate: new Date().toISOString(), bookmarkedPostIds:[] } as User,
          likedBy: postLikedBy.map(id => new ObjectId(id.toString())),
          likeCount: postDoc.likeCount || 0,
          isLikedByCurrentUser,
          commentIds: Array.isArray(postDoc.commentIds) ? postDoc.commentIds.map((id: ObjectId | string) => typeof id === 'string' ? new ObjectId(id) : id) : [],
          comments: recentCommentsPopulated.reverse(), 
          commentCount: postDoc.commentCount || 0,
          isBookmarkedByCurrentUser,
        } as Post;
      })
    );

    return NextResponse.json(enrichedPosts, { status: 200 });
  } catch (error) {
    console.error('API Error fetching posts:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred while fetching posts.';
    return NextResponse.json({ message: errorMessage, posts: [], comments: [] }, { status: 500 });
  }
}

