
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import type { Event, User } from '@/lib/types';
import getDb from '@/lib/mongodb';
import { ObjectId } from 'mongodb';

const eventFormSchema = z.object({
  organizerId: z.string(), // From authenticated user on client
  title: z.string().min(3, 'Title must be at least 3 characters.').max(100),
  description: z.string().min(10, 'Description must be at least 10 characters.').max(2000),
  startTime: z.string().datetime({ message: "Invalid start date format. Expected ISO string."}),
  endTime: z.string().datetime({ message: "Invalid end date format. Expected ISO string."}),
  location: z.string().optional(),
  category: z.string().optional(),
  tags: z.string().optional(), 
  maxAttendees: z.preprocess(
    (val) => (val === '' || val === undefined || val === null ? undefined : Number(val)),
    z.number().int().positive().optional()
  ),
  imageUrl: z.string().url().optional(),
}).refine(data => new Date(data.endTime) > new Date(data.startTime), {
  message: "End date and time must be after start date and time.",
  path: ["endTime"],
});


export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    if (!body.organizerId) {
        return NextResponse.json({ message: 'Organizer ID is required.' }, { status: 400 });
    }
    const db = await getDb();
    const usersCollection = db.collection<User>('users');
    const organizer = await usersCollection.findOne({ _id: new ObjectId(body.organizerId) });

    if (!organizer) {
        return NextResponse.json({ message: 'Organizer not found.' }, { status: 404 });
    }

    const validation = eventFormSchema.safeParse(body);
    if (!validation.success) {
      return NextResponse.json({ message: 'Invalid event data.', errors: validation.error.flatten() }, { status: 400 });
    }
    const data = validation.data;

    const newEventDocument = {
      organizerId: new ObjectId(data.organizerId),
      title: data.title,
      description: data.description,
      startTime: data.startTime,
      endTime: data.endTime,
      location: data.location,
      category: data.category,
      tags: data.tags ? data.tags.split(',').map(tag => tag.trim()).filter(tag => tag) : [],
      maxAttendees: data.maxAttendees,
      imageUrl: data.imageUrl || `https://placehold.co/1200x400.png`,
      rsvpIds: [],
      // _id will be generated by MongoDB
    };

    const eventsCollection = db.collection('events');
    const result = await eventsCollection.insertOne(newEventDocument);

    if(!result.insertedId) {
        throw new Error('Failed to insert event into database.');
    }

    const createdEventForResponse: Event = {
        ...newEventDocument,
        _id: result.insertedId,
        id: result.insertedId.toHexString(),
        organizerId: newEventDocument.organizerId.toHexString(), // Convert ObjectId to string
        rsvpIds: [], // Ensure it's an empty array of strings for client
    };

    return NextResponse.json({ message: 'Event created successfully!', event: createdEventForResponse }, { status: 201 });

  } catch (error) {
    console.error('API Error creating event:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred.';
    return NextResponse.json({ message: errorMessage }, { status: 500 });
  }
}

export async function GET(request: NextRequest) {
  try {
    const db = await getDb();
    const eventsCollection = db.collection('events');
    const usersCollection = db.collection<User>('users');

    const eventsFromDb = await eventsCollection.find({}).sort({ startTime: 1 }).toArray();

    const enrichedEvents = await Promise.all(eventsFromDb.map(async (event) => {
      const organizerDoc = await usersCollection.findOne({ _id: new ObjectId(event.organizerId as string) });
      const organizerForClient: User | undefined = organizerDoc ? {
        id: organizerDoc._id!.toHexString(),
        _id: organizerDoc._id,
        name: organizerDoc.name,
        email: organizerDoc.email,
        avatarUrl: organizerDoc.avatarUrl,
        bio: organizerDoc.bio,
        reputation: organizerDoc.reputation,
        joinedDate: organizerDoc.joinedDate,
      } : undefined;
      
      const rsvpUsers: User[] = [];
      if (event.rsvpIds && event.rsvpIds.length > 0) {
        const rsvpUserDocs = await usersCollection.find({ _id: { $in: event.rsvpIds.map(id => new ObjectId(id as string)) } }).toArray();
        rsvpUserDocs.forEach(doc => {
            rsvpUsers.push({
                id: doc._id!.toHexString(),
                _id: doc._id,
                name: doc.name,
                email: doc.email,
                avatarUrl: doc.avatarUrl,
                bio: doc.bio,
                reputation: doc.reputation,
                joinedDate: doc.joinedDate,
            });
        });
      }
      
      return {
        ...event,
        id: event._id.toHexString(),
        organizerId: event.organizerId.toString(),
        organizer: organizerForClient || { id: 'unknown', name: 'Unknown User', reputation: 0, joinedDate: new Date().toISOString() } as User,
        rsvps: rsvpUsers,
        rsvpIds: event.rsvpIds.map(id => id.toString()), // Ensure rsvpIds are strings
      };
    }));

    return NextResponse.json(enrichedEvents, { status: 200 });
  } catch (error) {
    console.error('API Error fetching events:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred.';
    return NextResponse.json({ message: errorMessage }, { status: 500 });
  }
}
